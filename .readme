UIKit Integration
If you want to present the Authenticator and dismiss it once the token is received, make sure your UIViewController conforms to the UIKitOAuthPresentable protocol.

import UIKit
import Authenticator

class ViewController: UIViewController, UIKitOAuthPresentable {
    
    var token = ""

    override func viewDidLoad() {
        super.viewDidLoad()
        getToken()
    }

    func getToken() {
        presentAuthenticator(
            urlString: "https://nightly-accounts-api.complyment.com/authz-srv/authz",
            clientId: "236b91c8-b2f0-4891-a83c-f358a109a843",
            redirectUri: "http://localhost:3000",
            onAccessTokenReceived: { [weak self] token in
                self?.token = token
            }
        )
    }
}
Note: If you need more control over how the Authenticator is presented and dismissed, initialize the Authenticator directly as a WKWebView and embed it where needed.




SwiftUI Integration
For SwiftUI, create an AuthenticatorView with an AuthenticatorViewModel that exposes an accessToken publisher.


import SwiftUI
import Authenticator
import Combine

struct ContentView: View {
    
    @ObservedObject var viewModel = AuthenticatorViewModel(
        urlString: "https://nightly-accounts-api.complyment.com/authz-srv/authz",
        clientId: "236b91c8-b2f0-4891-a83c-f358a109a843",
        redirectUri: "http://localhost:3000"
    )
    
    @State var cancellable: AnyCancellable?

    var body: some View {
        VStack {
            AuthenticatorView(viewModel: viewModel)
        }
        .task {
            self.cancellable = viewModel.accessToken.sink { token in
                print(token)
            }
        }
    }
}


Feel free to adjust the URLs, client IDs, and redirect URIs as needed for your specific use case.






